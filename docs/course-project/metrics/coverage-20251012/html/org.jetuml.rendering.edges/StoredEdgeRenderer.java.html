<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StoredEdgeRenderer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JetUML</a> &gt; <a href="index.source.html" class="el_package">org.jetuml.rendering.edges</a> &gt; <span class="el_source">StoredEdgeRenderer.java</span></div><h1>StoredEdgeRenderer.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * JetUML - A desktop application for fast UML diagramming.
 *
 * Copyright (C) 2025 by McGill University.
 *     
 * See: https://github.com/prmr/JetUML
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses.
 *******************************************************************************/
package org.jetuml.rendering.edges;

import static org.jetuml.rendering.EdgePriority.priorityOf;

import java.util.Optional;

import org.jetuml.diagram.DiagramElement;
import org.jetuml.diagram.DiagramType;
import org.jetuml.diagram.Edge;
import org.jetuml.diagram.edges.AggregationEdge;
import org.jetuml.diagram.edges.AggregationEdge.Type;
import org.jetuml.diagram.edges.AssociationEdge;
import org.jetuml.diagram.edges.AssociationEdge.Directionality;
import org.jetuml.diagram.edges.DependencyEdge;
import org.jetuml.diagram.edges.GeneralizationEdge;
import org.jetuml.diagram.edges.SingleLabelEdge;
import org.jetuml.diagram.edges.ThreeLabelEdge;
import org.jetuml.geom.Alignment;
import org.jetuml.geom.Dimension;
import org.jetuml.geom.Line;
import org.jetuml.geom.Point;
import org.jetuml.geom.Rectangle;
import org.jetuml.gui.ColorScheme;
import org.jetuml.rendering.ArrowHead;
import org.jetuml.rendering.ClassDiagramRenderer;
import org.jetuml.rendering.DiagramRenderer;
import org.jetuml.rendering.EdgePath;
import org.jetuml.rendering.EdgePriority;
import org.jetuml.rendering.LineStyle;
import org.jetuml.rendering.RenderingContext;
import org.jetuml.rendering.GraphicsRenderingContext;
import org.jetuml.rendering.StringRenderer;

import javafx.scene.canvas.Canvas;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.shape.Shape;

/**
 * Renders the path of stored class diagram edges using EdgeStorage.
 */
public class StoredEdgeRenderer extends AbstractEdgeRenderer
{
<span class="fc" id="L65">	private static final StringRenderer TOP_CENTERED_STRING_VIEWER = new StringRenderer(Alignment.CENTER);</span>
<span class="fc" id="L66">	private static final StringRenderer BOTTOM_CENTERED_STRING_VIEWER = new StringRenderer(Alignment.CENTER);</span>
<span class="fc" id="L67">	private static final StringRenderer LEFT_JUSTIFIED_STRING_VIEWER = new StringRenderer(Alignment.LEFT);</span>
<span class="fc" id="L68">	private static final int SINGLE_CHAR_WIDTH = LEFT_JUSTIFIED_STRING_VIEWER.getDimension(&quot; &quot;).width();</span>
<span class="fc" id="L69">	private static final int SIGLE_CHAR_HEIGHT = LEFT_JUSTIFIED_STRING_VIEWER.getDimension(&quot; &quot;).height();</span>
	private static final int DEGREES_180 = 180;
	
	/**
	 * @param pParent The renderer for the parent diagram.
	 */
	public StoredEdgeRenderer(DiagramRenderer pParent)
	{
<span class="fc" id="L77">		super(pParent);</span>
<span class="fc" id="L78">	}</span>
	
	/**
	 * Gets the line style for pEdge.
	 * @param pEdge the edge of interest
	 * @return the LineStyle of pEdge
	 * @pre pEdge !=null
	 */
	private static LineStyle getLineStyle(Edge pEdge)
	{
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">		assert pEdge !=null;</span>
<span class="fc bfc" id="L89" title="All 4 branches covered.">		if(priorityOf(pEdge) == EdgePriority.IMPLEMENTATION || priorityOf(pEdge) == EdgePriority.DEPENDENCY)</span>
		{
<span class="fc" id="L91">			return LineStyle.DOTTED;</span>
		}
		else
		{
<span class="fc" id="L95">			return LineStyle.SOLID;</span>
		}
	}
	
	/**
	 * Gets the start arrow for pEdge.
	 * @param pEdge the edge of interest
	 * @return the start arrow for pEdge
	 * @pre pEdge !=null
	 */
	private static ArrowHead getArrowStart(Edge pEdge)
	{
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">		assert pEdge !=null;</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">		if(pEdge instanceof AggregationEdge edge)</span>
		{
<span class="fc bfc" id="L110" title="All 2 branches covered.">			if(edge.getType() == Type.Composition)</span>
			{
<span class="fc" id="L112">				return ArrowHead.BLACK_DIAMOND;</span>
			}
			else
			{
<span class="fc" id="L116">				return ArrowHead.DIAMOND;</span>
			}
		}
<span class="fc bfc" id="L119" title="All 2 branches covered.">		else if(pEdge instanceof AssociationEdge edge)</span>
		{
<span class="fc bfc" id="L121" title="All 2 branches covered.">			if(edge.getDirectionality() == Directionality.Bidirectional)</span>
			{
<span class="fc" id="L123">				return ArrowHead.V;</span>
			}
		}
<span class="fc bfc" id="L126" title="All 2 branches covered.">		else if(pEdge instanceof DependencyEdge edge)</span>
		{
<span class="fc bfc" id="L128" title="All 2 branches covered.">			if(edge.getDirectionality() == DependencyEdge.Directionality.Bidirectional)</span>
			{
<span class="fc" id="L130">				return ArrowHead.V;</span>
			}
		}
<span class="fc" id="L133">		return ArrowHead.NONE;</span>
	}
	
	/**
	 * Gets the end arrow for pEdge.
	 * @param pEdge the edge of interest
	 * @return the end arrow for pEdge
	 * @pre pEdge !=null
	 */
	private static ArrowHead getArrowEnd(Edge pEdge)
	{
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">		assert pEdge !=null;</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">		if(pEdge instanceof GeneralizationEdge)</span>
		{
<span class="fc" id="L147">			return ArrowHead.TRIANGLE;</span>
		}
<span class="fc bfc" id="L149" title="All 2 branches covered.">		else if( pEdge instanceof AggregationEdge)</span>
		{
<span class="fc" id="L151">			return ArrowHead.NONE;</span>
		}
<span class="fc bfc" id="L153" title="All 2 branches covered.">		else if(pEdge instanceof DependencyEdge)</span>
		{
<span class="fc" id="L155">			return ArrowHead.V;</span>
		}
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">		else if(pEdge instanceof AssociationEdge edge)</span>
		{
<span class="fc bfc" id="L159" title="All 2 branches covered.">			if(edge.getDirectionality() == AssociationEdge.Directionality.Unidirectional || </span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">					edge.getDirectionality() == AssociationEdge.Directionality.Bidirectional)</span>
			{
<span class="fc" id="L162">				return ArrowHead.V;</span>
			}	
		}
<span class="fc" id="L165">		return ArrowHead.NONE;</span>
		
	}

	/**
	 * Uses the stored EdgePath of pEdge to create Path representation of its trajectory. 
	 * @param pEdge the edge of interest
	 * @return a Path representing the path of pEdge
	 * @pre pEdge!=null;
	 */
	private Path getSegmentPath(Edge pEdge) 
	{
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">		assert pEdge != null;</span>
<span class="fc" id="L178">		Path shape = new Path();</span>
<span class="fc" id="L179">		EdgePath path = getStoredEdgePath(pEdge);</span>
<span class="fc" id="L180">		shape.getElements().add(new MoveTo(path.getStartPoint().x(), path.getStartPoint().y()));</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">		for(int i = 1; i &lt; path.size(); i++)</span>
		{
<span class="fc" id="L183">			Point point = path.getPointByIndex(i);</span>
<span class="fc" id="L184">			shape.getElements().add(new LineTo(point.x(), point.y()));</span>
		}
<span class="fc" id="L186">		return shape;</span>
	}

	/**
	 * Returns whether an edge is segmented and is a step up. 
	 * @param pEdge the edge of interest
	 * @return true if edge is a step up, false otherwise.
	 */
	private boolean isStepUp(Edge pEdge) 
	{
<span class="fc" id="L196">		Point point1 = getStoredEdgePath(pEdge).getStartPoint();</span>
<span class="fc" id="L197">		Point point2 = getStoredEdgePath(pEdge).getEndPoint();</span>
<span class="pc bpc" id="L198" title="1 of 4 branches missed.">		return point1.x() &lt; point2.x() &amp;&amp; point1.y() &gt; point2.y() || </span>
<span class="fc bfc" id="L199" title="All 4 branches covered.">				point1.x() &gt; point2.x() &amp;&amp; point1.y() &lt; point2.y();</span>
	}
	
	/*
	 * Draws a label for an edge.
	 * 
	 * @param pGraphics the graphics context
	 * @param pEndPoint1 an endpoint of the segment along which to draw the string
	 * @param pEndPoint2 the other endpoint of the segment along which to draw the string
	 * @param pString the string to draw 
	 * @param pCenter true if the string should be centered along the segment
	 */
	private static void drawLabel(RenderingContext pContext, Line pSegment, 
			ArrowHead pArrowHead, String pString, boolean pCenter, boolean pIsStepUp)
	{
<span class="nc bnc" id="L214" title="All 4 branches missed.">		if(pString == null || pString.length() == 0)</span>
		{
<span class="nc" id="L216">			return;</span>
		}
<span class="nc" id="L218">		String label = wrapLabel(pString, pSegment); </span>
<span class="nc" id="L219">		Rectangle bounds = getLabelBounds(pSegment, pArrowHead, label, pCenter, pIsStepUp);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">		if(pCenter) </span>
		{
<span class="nc bnc" id="L222" title="All 2 branches missed.">			if( pSegment.y2() &gt;= pSegment.y1() )</span>
			{
<span class="nc" id="L224">				TOP_CENTERED_STRING_VIEWER.draw(label, bounds, pContext);</span>
			}
			else
			{
<span class="nc" id="L228">				BOTTOM_CENTERED_STRING_VIEWER.draw(label, bounds, pContext);</span>
			}
		}
		else
		{
<span class="nc" id="L233">			LEFT_JUSTIFIED_STRING_VIEWER.draw(label, bounds, pContext);</span>
		}
<span class="nc" id="L235">	}</span>
	
	private static String wrapLabel(String pLabel, Line pSegment) 
	{
<span class="nc" id="L239">		Dimension distances = pSegment.distanceBetweenPoints();</span>
<span class="nc" id="L240">		int lineLength = MAX_LENGTH_FOR_NORMAL_FONT;</span>
<span class="nc" id="L241">		double distanceInXPerChar = distances.width() / SINGLE_CHAR_WIDTH;</span>
<span class="nc" id="L242">		double distanceInYPerChar = distances.height() / SIGLE_CHAR_HEIGHT;</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">		if( distances.width() &gt; 0)</span>
		{
<span class="nc" id="L245">			double angleInDegrees = Math.toDegrees(Math.atan(distanceInYPerChar/distanceInXPerChar));</span>
<span class="nc" id="L246">			lineLength = Math.max(MAX_LENGTH_FOR_NORMAL_FONT, (int)((distances.width() / 4) * (1 - angleInDegrees / DEGREES_180)));</span>
		}
<span class="nc" id="L248">		return wrapString(pLabel, lineLength);</span>
	}
	
	/*
	 * Computes the extent of a string that is drawn along a line segment.
	 * @param pSegment The segment to label
	 * @param pArrow The line decoration
	 * @param pLabel The label
	 * @param pCenter true if the string should be centered along the segment
	 * @return the rectangle enclosing the string
	*/
	private static Rectangle getLabelBounds(Line pSegment, ArrowHead pArrow, 
			String pLabel, boolean pCenter, boolean pIsStepUp)
	{
<span class="pc bpc" id="L262" title="1 of 4 branches missed.">		if(pLabel == null || pLabel.isEmpty())</span>
		{
<span class="fc" id="L264">			return new Rectangle(pSegment.x2(), pSegment.y2(), 0, 0);</span>
		}
<span class="fc" id="L266">		Dimension textDimensions = TOP_CENTERED_STRING_VIEWER.getDimension(pLabel);</span>
<span class="fc" id="L267">		Point attachmentPoint = getAttachmentPoint(pSegment, pArrow, textDimensions, pCenter, pIsStepUp);</span>
<span class="fc" id="L268">		return new Rectangle(attachmentPoint.x(), attachmentPoint.y(), textDimensions.width(), textDimensions.height());</span>
	}

	/*
	 * Computes the attachment point for drawing a string.
	 */
	private static Point getAttachmentPoint(Line pSegment, 
			ArrowHead pArrow, Dimension pDimension, boolean pCenter, boolean pIsStepUp)
	{    
<span class="fc" id="L277">		final int gap = 3;</span>
<span class="fc" id="L278">		double xoff = gap;</span>
<span class="fc" id="L279">		double yoff = -gap - pDimension.height();</span>
<span class="fc" id="L280">		Point attach = pSegment.point2();</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">		if( pCenter )</span>
		{
<span class="fc bfc" id="L283" title="All 2 branches covered.">			if( pSegment.x1() &gt; pSegment.x2()) </span>
			{ 
<span class="fc" id="L285">				return getAttachmentPoint(pSegment.reversed(), pArrow, pDimension, pCenter, pIsStepUp); </span>
			}
<span class="fc" id="L287">			attach = pSegment.center();</span>
<span class="pc bpc" id="L288" title="1 of 4 branches missed.">			if( pSegment.isVertical() &amp;&amp; pIsStepUp)</span>
			{
<span class="fc" id="L290">				yoff = gap;</span>
			}
<span class="pc bpc" id="L292" title="3 of 4 branches missed.">			else if( pSegment.isVertical() &amp;&amp; !pIsStepUp)</span>
			{
<span class="nc" id="L294">				yoff =  -gap-pDimension.height();</span>
			}
<span class="fc bfc" id="L296" title="All 2 branches covered.">			else if( pSegment.isHorizontal())</span>
			{
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">				if(pDimension.width() &gt; pSegment.distanceBetweenPoints().width())</span>
				{
<span class="nc" id="L300">					attach = new Point(pSegment.x2() + (pDimension.width() / 2) + gap, </span>
<span class="nc" id="L301">							(pSegment.y1() + pSegment.y2()) / 2);</span>
				}
<span class="fc" id="L303">				xoff = -pDimension.width() / 2;</span>
			}
		}
		else 
		{
<span class="fc bfc" id="L308" title="All 2 branches covered.">			if(pSegment.x1() &lt; pSegment.x2())</span>
			{
<span class="fc" id="L310">				xoff = -gap - pDimension.width();</span>
			}
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">			if(pSegment.y1() &gt; pSegment.y2())</span>
			{
<span class="nc" id="L314">				yoff = gap;</span>
			}
<span class="fc bfc" id="L316" title="All 2 branches covered.">			if(pArrow != ArrowHead.NONE)</span>
			{
<span class="fc" id="L318">				Rectangle arrowBounds = ArrowHeadRenderer.getBounds(pArrow, pSegment); </span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">				if(pSegment.isHorizontal())</span>
				{
<span class="fc" id="L321">					yoff -= arrowBounds.height() / 2;</span>
				}
<span class="nc bnc" id="L323" title="All 2 branches missed.">				else if(pSegment.isVertical())</span>
				{
<span class="nc" id="L325">					xoff += arrowBounds.width() / 2;</span>
				}
			}
		}
<span class="fc" id="L329">		return new Point((int) (attach.x() + xoff), (int) (attach.y() + yoff));</span>
	}
	
	/**
	 * Gets the start label for pEdge.
	 * @param pEdge the edge of interest
	 * @return the string start label for pEdge
	 * @pre pEdge != null
	 */
	private static String getStartLabel(Edge pEdge)
	{
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">		assert pEdge !=null;</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">		if(pEdge instanceof ThreeLabelEdge threeLabelEdge)</span>
		{
<span class="fc" id="L343">			return threeLabelEdge.getStartLabel();</span>
		}
		else
		{
<span class="fc" id="L347">			return &quot;&quot;;</span>
		}
	}
	
	/**
	 * Gets the middle label for pEdge.
	 * @param pEdge the edge of interest
	 * @return the String middle label for pEdge
	 * @pre pEdge != null
	 */
	private static String getMiddleLabel(Edge pEdge)
	{
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">		assert pEdge !=null;</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">		if(pEdge instanceof ThreeLabelEdge threeLabelEdge)</span>
		{
<span class="fc" id="L362">			return threeLabelEdge.getMiddleLabel();</span>
		}
<span class="fc bfc" id="L364" title="All 2 branches covered.">		else if(pEdge instanceof SingleLabelEdge singleLabelEdge)</span>
		{
<span class="fc" id="L366">			return singleLabelEdge.getMiddleLabel();</span>
		}
		else
		{
<span class="fc" id="L370">			return &quot;&quot;;</span>
		}
	}
	
	/**
	 * Gets the end label for pEdge.
	 * @param pEdge the edge of interest
	 * @return the String end label for pEdge
	 * @pre pEdge != null
	 */
	private static String getEndLabel(Edge pEdge)
	{
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">		assert pEdge !=null;</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">		if(pEdge instanceof ThreeLabelEdge threeLabelEdge)</span>
		{
<span class="fc" id="L385">			return threeLabelEdge.getEndLabel();</span>
		}
		else
		{
<span class="fc" id="L389">			return &quot;&quot;;</span>
		}
	}

	@Override
	public Rectangle getBounds(DiagramElement pElement) 
	{
<span class="fc" id="L396">		Edge edge = (Edge) pElement;</span>
<span class="fc" id="L397">		EdgePath path = getStoredEdgePath(edge);</span>
<span class="fc" id="L398">		Rectangle bounds = super.getBounds(edge);</span>
<span class="fc" id="L399">		bounds = bounds.add(getLabelBounds(segmentForStartLabel(path), getArrowStart(edge), getStartLabel(edge), false, isStepUp(edge)));</span>
<span class="fc" id="L400">		bounds = bounds.add(getLabelBounds(segmentForMiddleLabel(path), ArrowHead.NONE, getMiddleLabel(edge), true, isStepUp(edge))); </span>
<span class="fc" id="L401">		bounds = bounds.add(getLabelBounds(segmentForEndLabel(path), getArrowEnd(edge), getEndLabel(edge), false, isStepUp(edge)));</span>
<span class="fc" id="L402">		return bounds;</span>
	}

	@Override
	protected Shape getShape(Edge pEdge) 
	{
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">		assert pEdge != null;</span>
<span class="fc" id="L409">		return getSegmentPath(pEdge);</span>
	}

	@Override
	public void draw(DiagramElement pElement, RenderingContext pContext) 
	{
<span class="nc bnc" id="L415" title="All 4 branches missed.">		assert pElement !=null &amp;&amp; pContext != null;</span>
<span class="nc" id="L416">		Edge edge = (Edge) pElement;</span>
<span class="nc" id="L417">		EdgePath path = getStoredEdgePath(edge);</span>
<span class="nc" id="L418">		pContext.strokePath(getSegmentPath(edge), ColorScheme.get().stroke(), getLineStyle(edge));</span>
<span class="nc" id="L419">		ArrowHeadRenderer.draw(pContext, getArrowStart(edge), path.getPointByIndex(1), path.getStartPoint());</span>
<span class="nc" id="L420">		ArrowHeadRenderer.draw(pContext, getArrowEnd(edge), path.getPointByIndex(path.size()-2), path.getEndPoint());</span>

<span class="nc" id="L422">		drawLabel(pContext, segmentForStartLabel(path), getArrowStart(edge), getStartLabel(edge), false, isStepUp(edge));</span>
<span class="nc" id="L423">		drawLabel(pContext, segmentForMiddleLabel(path), ArrowHead.NONE, getMiddleLabel(edge), true, isStepUp(edge));</span>
<span class="nc" id="L424">		drawLabel(pContext, segmentForEndLabel(path), getArrowEnd(edge), getEndLabel(edge), false, isStepUp(edge));</span>
<span class="nc" id="L425">	}</span>
	
	/*
	 * @return The line segment used to position
	 */
	private static Line segmentForStartLabel(EdgePath pPath)
	{
<span class="fc" id="L432">		return new Line(pPath.getPointByIndex(1), pPath.getStartPoint());</span>
	}
	
	private static Line segmentForMiddleLabel(EdgePath pPath)
	{
		// If any point is the same we consider this is a straight path
<span class="pc bpc" id="L438" title="1 of 4 branches missed.">		if( pPath.size() == 4 &amp;&amp; (pPath.getPointByIndex(0).equals(pPath.getPointByIndex(1)) || </span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">				pPath.getPointByIndex(1).equals(pPath.getPointByIndex(2)) || </span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">				pPath.getPointByIndex(2).equals(pPath.getPointByIndex(3))))</span>
		{
<span class="fc" id="L442">			return new Line(pPath.getStartPoint(), pPath.getEndPoint());</span>
		}
<span class="fc" id="L444">		return new Line( pPath.getPointByIndex(pPath.size() / 2 - 1) , pPath.getPointByIndex(pPath.size() / 2));</span>
	}
	
	private static Line segmentForEndLabel(EdgePath pPath)
	{
<span class="fc" id="L449">		return new Line(pPath.getPointByIndex(pPath.size()-2), pPath.getPointByIndex(pPath.size()-1));</span>
	}

	@Override
	public Canvas createIcon(DiagramType pDiagramType, DiagramElement pElement) 
	{
<span class="fc" id="L455">		Edge edge = (Edge)pElement;</span>
<span class="fc" id="L456">		Canvas canvas = new Canvas(BUTTON_SIZE, BUTTON_SIZE);</span>
<span class="fc" id="L457">		Path path = new Path();</span>
<span class="fc" id="L458">		path.getElements().addAll(new MoveTo(OFFSET, OFFSET), new LineTo(BUTTON_SIZE-OFFSET, BUTTON_SIZE-OFFSET));</span>
<span class="fc" id="L459">		GraphicsRenderingContext context = new GraphicsRenderingContext(canvas.getGraphicsContext2D());</span>
<span class="fc" id="L460">		context.strokePath(path, ColorScheme.get().stroke(), getLineStyle(edge));</span>
		
<span class="fc" id="L462">		ArrowHeadRenderer.draw(context, getArrowEnd(edge), </span>
				new Point(OFFSET, OFFSET), new Point(BUTTON_SIZE-OFFSET, BUTTON_SIZE - OFFSET));
<span class="fc" id="L464">		ArrowHeadRenderer.draw(context, getArrowStart(edge), </span>
				new Point(BUTTON_SIZE-OFFSET, BUTTON_SIZE - OFFSET), new Point(OFFSET, OFFSET));
<span class="fc" id="L466">		return canvas;</span>
	}

	@Override
	public boolean contains(DiagramElement pElement, Point pPoint) 
	{
		// Purposefully does not include the arrow head and labels, which create large bounds.
<span class="fc" id="L473">		EdgePath path = getStoredEdgePath((Edge)pElement);</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">		if(path == null)</span>
		{
<span class="nc" id="L476">			return false;</span>
		}
		else
		{
<span class="fc bfc" id="L480" title="All 4 branches covered.">			if(pPoint.distance(path.getStartPoint()) &lt;= MAX_DISTANCE || pPoint.distance(path.getEndPoint()) &lt;= MAX_DISTANCE)</span>
			{
<span class="fc" id="L482">				return true;</span>
			}
<span class="fc" id="L484">			Shape fatPath = getShape((Edge)pElement);</span>
<span class="fc" id="L485">			fatPath.setStrokeWidth(2 * MAX_DISTANCE);</span>
<span class="fc" id="L486">			return fatPath.contains(pPoint.x(), pPoint.y());</span>
		}
	}

	@Override
	public Line getConnectionPoints(Edge pEdge) 
	{
<span class="fc" id="L493">		return new Line(getStoredEdgePath(pEdge).getStartPoint(), </span>
<span class="fc" id="L494">				getStoredEdgePath(pEdge).getEndPoint());</span>
	}
	
	/**
	 * Gets the EdgePath of pEdge from EdgeStorage.
	 * @param pEdge the edge of interest
	 * @return the EdgePath of pEdge from storage
	 * @pre pEdge is present in EdgeStorage
	 */
	private EdgePath getStoredEdgePath(Edge pEdge)
	{
<span class="fc" id="L505">		Optional&lt;EdgePath&gt; edgePath = ((ClassDiagramRenderer)parent()).getStoredEdgePath(pEdge);</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">		assert edgePath.isPresent();</span>
<span class="fc" id="L507">		return edgePath.get();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>