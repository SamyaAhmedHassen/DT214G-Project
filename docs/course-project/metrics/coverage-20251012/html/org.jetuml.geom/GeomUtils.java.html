<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeomUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JetUML</a> &gt; <a href="index.source.html" class="el_package">org.jetuml.geom</a> &gt; <span class="el_source">GeomUtils.java</span></div><h1>GeomUtils.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * JetUML - A desktop application for fast UML diagramming.
 *
 * Copyright (C) 2025 by McGill University.
 *     
 * See: https://github.com/prmr/JetUML
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses.
 *******************************************************************************/
package org.jetuml.geom;

import static java.lang.Math.cos;
import static java.lang.Math.sin;
import static java.lang.Math.toRadians;

/**
 * A collection of utility methods related to geometric
 * calculations and supporting functions.
 */
<span class="fc" id="L31">public final class GeomUtils</span>
{
	private GeomUtils()
	{}
	
	/**
	 * @param pArguments Arguments to test
	 * @return The maximum value of all arguments.
	 * @pre pArguments.length &gt; 0
	 */
	public static int max(int... pArguments)
	{
<span class="pc bpc" id="L43" title="1 of 2 branches missed.">		assert pArguments.length &gt; 0;</span>
<span class="fc" id="L44">		int result = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L45" title="All 2 branches covered.">		for( int argument : pArguments)</span>
		{
<span class="fc bfc" id="L47" title="All 2 branches covered.">			if( argument &gt; result )</span>
			{
<span class="fc" id="L49">				result = argument;</span>
			}
		}
<span class="fc" id="L52">		return result;</span>
	}
	
	/*
	 * Returns the point that intersects the line that runs in direction pDirection from
	 * the center of pRectangle, with one side of pRectangle.
	 * @pre pDirection.isCardinal()
	 */
	private static Point intersectionForCardinalDirection(Rectangle pRectangle, Direction pDirection)
	{
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">		assert pDirection.isCardinal();</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">		if( pDirection == Direction.NORTH )</span>
		{
<span class="fc" id="L65">			return new Point(pRectangle.center().x(), pRectangle.y());</span>
		}
<span class="fc bfc" id="L67" title="All 2 branches covered.">		else if( pDirection == Direction.SOUTH )</span>
		{
<span class="fc" id="L69">			return new Point(pRectangle.center().x(), pRectangle.maxY());</span>
		}
<span class="fc bfc" id="L71" title="All 2 branches covered.">		else if( pDirection == Direction.EAST )</span>
		{
<span class="fc" id="L73">			return new Point(pRectangle.maxX(), pRectangle.center().y());</span>
		}
		else // pDirection == Direction.WEST 
		{
<span class="fc" id="L77">			return new Point(pRectangle.x(), pRectangle.center().y());</span>
		}
	}
	
	/**
	 * @param pRectangle The rectangle to intersect with.
	 * @param pDirection The direction to follow to intersect the sides of the rectangle.
	 * @return The point that intersects pRectangle if we draw a line from its center going
	 *     in direction pDirection.
	 * @pre pRectangle != null &amp;&amp; pDirection != null
	 */
	public static Point intersectRectangle(Rectangle pRectangle, Direction pDirection)
	{
<span class="pc bpc" id="L90" title="2 of 4 branches missed.">		assert pRectangle != null &amp;&amp; pDirection != null;</span>
		
<span class="fc bfc" id="L92" title="All 2 branches covered.">		if( pDirection.isCardinal() )</span>
		{
<span class="fc" id="L94">			return intersectionForCardinalDirection(pRectangle, pDirection);</span>
		}
		
<span class="fc" id="L97">		Direction diagonalNE = Direction.fromLine(pRectangle.center(), new Point(pRectangle.maxX(), pRectangle.y()));</span>
<span class="fc" id="L98">		Direction diagonalSE = Direction.fromLine(pRectangle.center(), new Point(pRectangle.maxX(), pRectangle.maxY()));</span>
<span class="fc" id="L99">		Direction diagonalSW = diagonalNE.mirrored();</span>
<span class="fc" id="L100">		Direction diagonalNW = diagonalSE.mirrored();</span>
		
<span class="fc bfc" id="L102" title="All 2 branches covered.">		if( pDirection.isBetween(diagonalNE, diagonalSE.rotatedBy(1)))</span>
		{
<span class="fc" id="L104">			int offset = lengthOfOpposingSide(pDirection.asAngle() - Direction.EAST.asAngle(), pRectangle.width()/2);</span>
<span class="fc" id="L105">			return new Point(pRectangle.maxX(), pRectangle.center().y() + offset);</span>
		}
<span class="fc bfc" id="L107" title="All 2 branches covered.">		else if( pDirection.isBetween(diagonalSE, diagonalSW.rotatedBy(1)))</span>
		{
<span class="fc" id="L109">			int offset = lengthOfOpposingSide(pDirection.asAngle() - Direction.SOUTH.asAngle(), pRectangle.height()/2);</span>
<span class="fc" id="L110">			return new Point(pRectangle.center().x() - offset, pRectangle.maxY());</span>
		}
<span class="fc bfc" id="L112" title="All 2 branches covered.">		else if( pDirection.isBetween(diagonalSW, diagonalNW.rotatedBy(1)))</span>
		{
<span class="fc" id="L114">			int offset = lengthOfOpposingSide(pDirection.asAngle() - Direction.WEST.asAngle(), pRectangle.width()/2);</span>
<span class="fc" id="L115">			return new Point(pRectangle.x(), pRectangle.center().y() - offset);</span>
		}
		else
		{
<span class="fc" id="L119">			final int angleS = 360;</span>
<span class="fc" id="L120">			int offset = lengthOfOpposingSide(pDirection.asAngle() - angleS, pRectangle.height()/2);</span>
<span class="fc" id="L121">			return new Point(pRectangle.center().x() + offset, pRectangle.y());</span>
		}
	}
	
	/**
	 * Returns the point that intersects a circle on the line that originates
	 * at the center of pBounds going in direction pDirection. 
	 * 
	 * @param pBounds The bounds of the rectangle in which the circle to intersect in inscribed.
	 * @param pDirection The direction to follow to intersect the sides of the circle.
	 * @return The point that intersects the circle inscribed in pBounds if we draw a line from its center going
	 *     in direction pDirection.
	 * @pre pBounds != null &amp;&amp; pDirection != null &amp;&amp; pBounds.getWidth() == pBounds.getHeight()
	 */
	public static Point intersectCircle(Rectangle pBounds, Direction pDirection)
	{
<span class="pc bpc" id="L137" title="3 of 6 branches missed.">		assert pBounds != null &amp;&amp; pDirection != null &amp;&amp; pBounds.width() == pBounds.height();</span>
		
<span class="fc bfc" id="L139" title="All 2 branches covered.">		if( pDirection.isCardinal() )</span>
		{
<span class="fc" id="L141">			return intersectionForCardinalDirection(pBounds, pDirection);</span>
		}
		
<span class="fc" id="L144">		final int radius = pBounds.width()/2;</span>
		
<span class="fc" id="L146">		int offsetX = round(cos(toRadians(pDirection.asAngle() - Direction.EAST.asAngle())) * radius);</span>
<span class="fc" id="L147">		int offsetY = round(sin(toRadians(pDirection.asAngle() - Direction.EAST.asAngle())) * radius);</span>
<span class="fc" id="L148">		return new Point( pBounds.center().x() + offsetX, pBounds.center().y() + offsetY);</span>
	}   	 
	
	/**
	 * Returns the point that intersects a ellipse on the line that originates
	 * at the center of pBounds going in direction pDirection. 
	 * 
	 * @param pBounds The bounds of the rectangle in which the ellipse to intersect in inscribed.
	 * @param pDirection The direction to follow to intersect the sides of the ellipse.
	 * @return The point that intersects the ellipse inscribed in pBounds if we draw a line from its 
	 *     center going in direction pDirection.
	 * @pre pBounds != null &amp;&amp; pDirection != null
	 */
	public static Point intersectEllipse(Rectangle pBounds, Direction pDirection)
	{
<span class="pc bpc" id="L163" title="2 of 4 branches missed.">		assert pBounds != null &amp;&amp; pDirection != null;</span>
		
<span class="fc bfc" id="L165" title="All 2 branches covered.">		if( pDirection.isCardinal() )</span>
		{
<span class="fc" id="L167">			return intersectionForCardinalDirection(pBounds, pDirection);</span>
		}
		
<span class="fc" id="L170">		final int a = pBounds.width()/2;</span>
<span class="fc" id="L171">		final int b = pBounds.height()/2;</span>
		
<span class="fc" id="L173">		int offsetX = round(cos(toRadians(pDirection.asAngle() - Direction.EAST.asAngle())) * a);</span>
<span class="fc" id="L174">		int offsetY = round(sin(toRadians(pDirection.asAngle() - Direction.EAST.asAngle())) * b);</span>
<span class="fc" id="L175">		return new Point( pBounds.center().x() + offsetX, pBounds.center().y() + offsetY);</span>
	}

	/**
	 * @param pBounds The bounds of the rectangle in which the rounded rectangle to intersect in inscribed.
	 * @param pDirection The direction to follow to intersect the sides of the rounded rectangle.
	 * @return The point that intersects the rounded rectangle inscribed in pBounds if we draw a line from 
	 * 	   its center going in direction pDirection.
	 * @pre pBounds != null &amp;&amp; pDirection != null
	 */
	public static Point intersectRoundedRectangle(Rectangle pBounds, Direction pDirection)
	{
<span class="pc bpc" id="L187" title="2 of 4 branches missed.">		assert pBounds != null &amp;&amp; pDirection != null;</span>
		
<span class="fc bfc" id="L189" title="All 2 branches covered.">		if( pDirection.isCardinal() )</span>
		{
<span class="fc" id="L191">			return intersectionForCardinalDirection(pBounds, pDirection);</span>
		}
		
<span class="fc" id="L194">		final int arcSize = 20; // same as the value in viewUtils</span>
<span class="fc" id="L195">		int radius = arcSize/2;</span>
<span class="fc" id="L196">		int widthOffset = pBounds.width()/2 - radius;</span>
<span class="fc" id="L197">		int heightOffset = pBounds.height()/2 - radius;</span>
		
		// calculate bounds of rounded corner
<span class="fc" id="L200">		Direction topNE = Direction.fromLine(pBounds.center(), new Point(pBounds.maxX() - radius, pBounds.y()));</span>
<span class="fc" id="L201">		Direction bottomNE = Direction.fromLine(pBounds.center(), new Point(pBounds.maxX(), pBounds.y() + radius));</span>
<span class="fc" id="L202">		Direction topSE = Direction.fromLine(pBounds.center(), new Point(pBounds.maxX(), pBounds.maxY() - radius));</span>
<span class="fc" id="L203">		Direction bottomSE = Direction.fromLine(pBounds.center(), new Point(pBounds.maxX() - radius, pBounds.maxY()));</span>
<span class="fc" id="L204">		Direction topSW = topNE.mirrored(); </span>
<span class="fc" id="L205">		Direction bottomSW = bottomNE.mirrored();</span>
<span class="fc" id="L206">		Direction topNW = topSE.mirrored();</span>
<span class="fc" id="L207">		Direction bottomNW = bottomSE.mirrored();</span>
		
<span class="fc" id="L209">		Point rectangleIntersectionPoint = intersectRectangle(pBounds, pDirection);</span>
<span class="fc" id="L210">		Point result = null;</span>
		
<span class="fc bfc" id="L212" title="All 2 branches covered.">		if( pDirection.isBetween(topNE, bottomNE))</span>
		{
<span class="fc" id="L214">			Point cornerCenter = new Point(pBounds.center().x() + widthOffset, pBounds.center().y() - heightOffset);</span>
<span class="fc" id="L215">			Direction cornerDirection = Direction.fromLine(cornerCenter, rectangleIntersectionPoint);</span>
<span class="fc" id="L216">			int offsetX = round(cos(toRadians(cornerDirection.asAngle() - Direction.EAST.asAngle())) * radius);</span>
<span class="fc" id="L217">			int offsetY = round(sin(toRadians(cornerDirection.asAngle() - Direction.EAST.asAngle())) * radius);</span>
<span class="fc" id="L218">			result =  new Point( pBounds.center().x() + offsetX + widthOffset, pBounds.center().y() + offsetY - heightOffset);</span>
<span class="fc" id="L219">		}</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">		else if( pDirection.isBetween(topSE, bottomSE))</span>
		{
<span class="fc" id="L222">			Point cornerCenter = new Point(pBounds.center().x() + widthOffset, pBounds.center().y() + heightOffset);</span>
<span class="fc" id="L223">			Direction cornerDirection = Direction.fromLine(cornerCenter, rectangleIntersectionPoint);</span>
<span class="fc" id="L224">			int offsetX = round(cos(toRadians(cornerDirection.asAngle() - Direction.EAST.asAngle())) * radius);</span>
<span class="fc" id="L225">			int offsetY = round(sin(toRadians(cornerDirection.asAngle() - Direction.EAST.asAngle())) * radius);</span>
<span class="fc" id="L226">			result = new Point( pBounds.center().x() + offsetX + widthOffset, pBounds.center().y() + offsetY + heightOffset);</span>
<span class="fc" id="L227">		}</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">		else if( pDirection.isBetween(topSW, bottomSW))</span>
		{
<span class="nc" id="L230">			Point cornerCenter = new Point(pBounds.center().x() - widthOffset, pBounds.center().y() + heightOffset);</span>
<span class="nc" id="L231">			Direction cornerDirection = Direction.fromLine(cornerCenter, rectangleIntersectionPoint);</span>
<span class="nc" id="L232">			int offsetX = round(cos(toRadians(cornerDirection.asAngle() - Direction.EAST.asAngle())) * radius);</span>
<span class="nc" id="L233">			int offsetY = round(sin(toRadians(cornerDirection.asAngle() - Direction.EAST.asAngle())) * radius);</span>
<span class="nc" id="L234">			result = new Point( pBounds.center().x() + offsetX - widthOffset, pBounds.center().y() + offsetY + heightOffset);</span>
<span class="nc" id="L235">		}</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">		else if( pDirection.isBetween(topNW, bottomNW))</span>
		{
<span class="fc" id="L238">			Point cornerCenter = new Point(pBounds.center().x() - widthOffset, pBounds.center().y() - heightOffset);</span>
<span class="fc" id="L239">			Direction cornerDirection = Direction.fromLine(cornerCenter, rectangleIntersectionPoint);</span>
<span class="fc" id="L240">			int offsetX = round(cos(toRadians(cornerDirection.asAngle() - Direction.EAST.asAngle())) * radius);</span>
<span class="fc" id="L241">			int offsetY = round(sin(toRadians(cornerDirection.asAngle() - Direction.EAST.asAngle())) * radius);</span>
<span class="fc" id="L242">			result = new Point( pBounds.center().x() + offsetX - widthOffset, pBounds.center().y() + offsetY - heightOffset);</span>
<span class="fc" id="L243">		}</span>
		else
		{
<span class="fc" id="L246">			result = rectangleIntersectionPoint;</span>
		}
		
<span class="fc" id="L249">		return result;</span>
	}
	
	/*
     * returns the length, in pixel, of the opposing side to the angle pAngleInDegrees
     * of a right triangle for when the length (in pixels) of the adjacent side is 
     * known.
 	 */
	private static int lengthOfOpposingSide(int pAngleInDegrees, int pAdjacentSide)
	{
<span class="fc" id="L259">		return round(pAdjacentSide * Math.tan(Math.toRadians(pAngleInDegrees)));</span>
	}
	
	/**
	 * Convenience method to round a number into an int. The input value is 
	 * expected to be within range of an integer. This implies that the value
	 * cannot be NaN or negative or positive infinity.
	 * @param pDouble Input number
	 * @return The closest integer to pDouble.
	 * @pre pDouble &gt;= Integer.MIN_VALUE &amp;&amp; pDouble &lt;= Integer.MAX_VALUE
	 */
	public static int round(double pDouble)
	{
<span class="pc bpc" id="L272" title="2 of 4 branches missed.">		assert pDouble &gt;= Integer.MIN_VALUE &amp;&amp; pDouble &lt;= Integer.MAX_VALUE;</span>
<span class="fc" id="L273">		return (int) Math.round(pDouble);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>