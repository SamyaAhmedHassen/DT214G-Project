<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SequenceDiagramRenderer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JetUML</a> &gt; <a href="index.source.html" class="el_package">org.jetuml.rendering</a> &gt; <span class="el_source">SequenceDiagramRenderer.java</span></div><h1>SequenceDiagramRenderer.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * JetUML - A desktop application for fast UML diagramming.
 *
 * Copyright (C) 2025 by McGill University.
 *     
 * See: https://github.com/prmr/JetUML
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses.
 ******************************************************************************/
package org.jetuml.rendering;

import static java.util.stream.Collectors.toList;

import java.util.Comparator;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import org.jetuml.diagram.Diagram;
import org.jetuml.diagram.DiagramElement;
import org.jetuml.diagram.Edge;
import org.jetuml.diagram.Node;
import org.jetuml.diagram.edges.CallEdge;
import org.jetuml.diagram.edges.ConstructorEdge;
import org.jetuml.diagram.edges.ReturnEdge;
import org.jetuml.diagram.nodes.CallNode;
import org.jetuml.diagram.nodes.ImplicitParameterNode;
import org.jetuml.geom.Point;
import org.jetuml.geom.Rectangle;
import org.jetuml.geom.Alignment;
import org.jetuml.rendering.edges.CallEdgeRenderer;
import org.jetuml.rendering.edges.ReturnEdgeRenderer;
import org.jetuml.rendering.nodes.CallNodeRenderer;
import org.jetuml.rendering.nodes.ImplicitParameterNodeRenderer;

/**
 * The renderer for sequence diagrams. The implementation of this renderer assumes
 * that any sequence diagram has either zero call nodes or a single root call node, namely, 
 * only one call node with no callers.
 */
public final class SequenceDiagramRenderer extends AbstractDiagramRenderer
{ 
	/*
	 * Number of pixels to drop the contructor activation box from. */
	private static final int CONSTRUCTOR_DROP = 5;

	/* Initial position of the lifeline of an object if it is not the target of a constructor call.  */
	private static final int INITIAL_Y_POSITION = 80;
	
	/* Minimum number of pixels to drop a new call edge from the current position in the call sequence.
	 * Should then be adjusted based on font size. See method getDropDistance() */
	private static final int DROP_MIN = 20;
	
	/* Number of pixels to drop a constructor call node from the current position in the call sequence. 
	 * Independent of font size. */
	private static final int DROP_CONSTRUCTOR = 85;
	
	/* Number of pixels to add to a call node below the bottom of its last callee. */
	private static final int BOTTOM_PADDING = 20;
	
	/* Height, in number of pixels, of a call node without any callees. */
	private static final int LEAF_NODE_HEIGHT = 30;
	
	/* Constants to test the height of the font. */
	private static final String TEST_STRING = &quot;|&quot;;
	
	/* Renderer used only for measuring string height */
<span class="fc" id="L82">	private static final StringRenderer STRING_METRIC = new StringRenderer(Alignment.LEFT);</span>

<span class="fc" id="L84">	private final Map&lt;Node, Integer&gt; aCallNodeTopCoordinate = new IdentityHashMap&lt;&gt;();</span>
<span class="fc" id="L85">	private final Map&lt;Node, Integer&gt; aCallNodeBottomCoordinate = new IdentityHashMap&lt;&gt;();</span>
	
	/**
	 * @param pDiagram The diagram being rendered.
	 */
	public SequenceDiagramRenderer(Diagram pDiagram)
	{
<span class="fc" id="L92">		super(pDiagram);</span>
<span class="fc" id="L93">		addElementRenderer(CallNode.class, new CallNodeRenderer(this));</span>
<span class="fc" id="L94">		addElementRenderer(ImplicitParameterNode.class, new ImplicitParameterNodeRenderer(this));</span>
<span class="fc" id="L95">		addElementRenderer(ReturnEdge.class, new ReturnEdgeRenderer(this));</span>
<span class="fc" id="L96">		addElementRenderer(CallEdge.class, new CallEdgeRenderer(this));</span>
<span class="fc" id="L97">		addElementRenderer(ConstructorEdge.class, new CallEdgeRenderer(this));</span>
<span class="fc" id="L98">	}</span>
	
	@Override
	public void draw(RenderingContext pContext)
	{
<span class="nc" id="L103">		layout();</span>
<span class="nc" id="L104">		super.draw(pContext); </span>
<span class="nc" id="L105">	}</span>
	
	/*
	 * Computes the position of the nodes in the sequence diagram, except the note nodes.
	 */
	private void layout()
	{
<span class="fc" id="L112">		computeYPositions();</span>
<span class="fc" id="L113">	}</span>
	
	/**
	 * @return true if no computations of nodes are found. This could be because the 
	 * diagram is empty, but also because it has been loaded from disk and before a rendering pass 
	 * has been done.
	 */
	private boolean noComputedPositionFound()
	{
<span class="fc" id="L122">		return aCallNodeTopCoordinate.isEmpty();</span>
	}
	
	@Override
	public Rectangle getBounds()
	{
		//When getBounds(pDiagram) is called to open an existing class diagram file,
		//the positions have not yet been computed and need to be.
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">		if(noComputedPositionFound())</span>
		{
<span class="fc" id="L132">			layout();</span>
		}
<span class="fc" id="L134">		return super.getBounds();</span>
	}
	
	/**
	 * @param pNode The implicit paramter node to check.
	 * @param pPoint The point to check.
	 * @return True if the top rectangle of pNode contains pPoint
	 */
	public boolean topRectangleContains(Node pNode, Point pPoint)
	{
<span class="pc bpc" id="L144" title="2 of 4 branches missed.">		assert pNode != null &amp;&amp; pNode instanceof ImplicitParameterNode;</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">		assert pPoint != null;</span>
<span class="fc" id="L146">		return ((ImplicitParameterNodeRenderer)rendererFor(pNode.getClass())).</span>
<span class="fc" id="L147">				getTopRectangle(pNode).contains(pPoint);</span>
	}
	
	/**
	 * Returns the caller of a node, if it exists.
	 * 
	 * @param pNode The node to obtain the caller for.
	 * @return The CallNode that has a outgoing edge terminated
	 *     at pNode, if there is one.
	 * @pre pNode != null &amp;&amp; contains(pNode)
	 */
	public Optional&lt;CallNode&gt; getCaller(Node pNode)
	{
<span class="pc bpc" id="L160" title="2 of 4 branches missed.">		assert pNode != null &amp;&amp; diagram().contains(pNode);</span>
<span class="fc" id="L161">		return diagram().edges().stream()</span>
<span class="fc" id="L162">			.filter(CallEdge.class::isInstance)</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">			.filter(edge -&gt; edge.end() == pNode)</span>
<span class="fc" id="L164">			.map(Edge::start)</span>
<span class="fc" id="L165">			.map(CallNode.class::cast)</span>
<span class="fc" id="L166">			.findFirst();</span>
	}
	
	/**
	 * @return The number of call nodes active on the same parent when
	 * this call nodes gets executed. An initial (non-nested) call 
	 * node on an implicit parameter get result 0. Nesting is generated
	 * not only by self-calls, but also by any call back to the 
	 * parent object.
	 */
	public int getNestingDepth(CallNode pNode)
	{
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">		assert pNode != null;</span>
<span class="fc" id="L179">		int result = 0;</span>
<span class="fc" id="L180">		Optional&lt;CallNode&gt; node = getCaller(pNode);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">		while( node.isPresent() )</span>
		{
<span class="fc bfc" id="L183" title="All 2 branches covered.">			if( node.get().getParent() == pNode.getParent() )</span>
			{
<span class="fc" id="L185">				result++;</span>
			}
<span class="fc" id="L187">			node = getCaller(node.get());</span>
		}
<span class="fc" id="L189">		return result;</span>
	}
	
	// This method assumes a single root nodes, and traces all call nodes
	// from this root node. This creates a problem when pasting implicit parameter
	// nodes that contain a dangling call node.
	private void computeYPositions()
	{
<span class="fc" id="L197">		aCallNodeTopCoordinate.clear();</span>
<span class="fc" id="L198">		aCallNodeBottomCoordinate.clear();</span>
<span class="fc" id="L199">		Optional&lt;Node&gt; root = findRoot();</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">		if( root.isEmpty() )</span>
		{
<span class="fc" id="L202">			return; // Empty call graph, normal case when creating a new diagram</span>
		}
<span class="fc" id="L204">		int currentYPosition = INITIAL_Y_POSITION;</span>
		// Position root node
<span class="fc" id="L206">		aCallNodeTopCoordinate.put(root.get(), currentYPosition);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">		for( Node callee : getCallees(root.get()))</span>
		{
<span class="fc" id="L209">			currentYPosition = computeYPosition(callee, currentYPosition);</span>
<span class="fc" id="L210">		}</span>
<span class="fc" id="L211">		aCallNodeBottomCoordinate.put(root.get(), currentYPosition + BOTTOM_PADDING);</span>
<span class="fc" id="L212">	}</span>
	
	/**
	 * @param pNode A callnode in this sequence diagram
	 * @return The Y-coordinate of the top of the node.
	 */
	public int getY(Node pNode)
	{
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">		assert pNode != null;</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">		assert aCallNodeTopCoordinate.containsKey(pNode);</span>
<span class="fc" id="L222">		return aCallNodeTopCoordinate.get(pNode);</span>
	}
	
	/**
	 * @param pNode A callnode in this sequence diagram
	 * @return The Y-coordinate of the bottom of the node.
	 */
	public int getMaxY(Node pNode)
	{
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">		assert pNode != null;</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">		assert aCallNodeBottomCoordinate.containsKey(pNode);</span>
<span class="fc" id="L233">		return aCallNodeBottomCoordinate.get(pNode);</span>
	}
	
	/*
	 * Computes the y position of the pNode call node, and all its callees,
	 * through recursive descent. Also adjust the parent in case it's a constructor call.
	 */
	private int computeYPosition(Node pNode, int pCurrentPosition)
	{
<span class="fc" id="L242">		int currentPosition = pCurrentPosition;</span>
		// If this is a constructor call, also adjust the parent.
<span class="fc bfc" id="L244" title="All 2 branches covered.">		if( isConstructorCall(pNode) )</span>
		{
<span class="fc" id="L246">			currentPosition += DROP_CONSTRUCTOR;</span>
		}
		else
		{
<span class="fc" id="L250">			currentPosition += getDropDistance();</span>
		}
<span class="fc" id="L252">		aCallNodeTopCoordinate.put(pNode, currentPosition);</span>
<span class="fc" id="L253">		List&lt;Node&gt; callees = getCallees(pNode);</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">		if( callees.isEmpty() )</span>
		{
<span class="fc" id="L256">			currentPosition += LEAF_NODE_HEIGHT;</span>
		}
		else
		{
<span class="fc bfc" id="L260" title="All 2 branches covered.">			for( Node callee : callees)</span>
			{
<span class="fc" id="L262">				currentPosition = computeYPosition(callee, currentPosition);</span>
<span class="fc" id="L263">			}</span>
<span class="fc" id="L264">			currentPosition += BOTTOM_PADDING;</span>
		} 
<span class="fc" id="L266">		aCallNodeBottomCoordinate.put(pNode, currentPosition);</span>
<span class="fc" id="L267">		return currentPosition;</span>
	}
	
	private boolean isConstructorCall(Node pNode)
	{
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">		assert pNode.getClass() == CallNode.class;</span>
<span class="fc" id="L273">		return getIncomingCall(pNode)</span>
<span class="fc" id="L274">					.filter(edge -&gt; edge instanceof ConstructorEdge) // Exists and is a constructor edge</span>
<span class="fc" id="L275">					.isPresent();</span>
	}
	
	private Optional&lt;Edge&gt; getIncomingCall(Node pNode)
	{
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">		assert pNode.getClass() == CallNode.class;</span>
<span class="fc" id="L281">		return diagram().edges().stream()</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">			.filter(edge -&gt; edge.end() == pNode)</span>
<span class="fc" id="L283">			.findFirst();</span>
	}
	
	/**
	 * @param pNode The node whose lifeline we're looking at.
	 * @return The y-coordinate of the top of this node's lifeline
	 */
	public int getLifelineTop(ImplicitParameterNode pNode)
	{
		// 20 if it's a normal call, 5 if a constructor call
<span class="fc" id="L293">		Optional&lt;Node&gt; topNode = diagram().allNodes().stream()</span>
<span class="fc" id="L294">			.filter(CallNode.class::isInstance)</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">			.filter(node -&gt; node.getParent() == pNode)</span>
<span class="fc" id="L296">			.sorted(Comparator.comparing(aCallNodeTopCoordinate::get))</span>
<span class="fc" id="L297">			.findFirst();</span>
<span class="fc bfc" id="L298" title="All 4 branches covered.">		if(topNode.isEmpty() || !isConstructorCall(topNode.get()))</span>
		{
<span class="fc" id="L300">			return INITIAL_Y_POSITION - DROP_MIN;</span>
		}
		else
		{
<span class="fc" id="L304">			return aCallNodeTopCoordinate.get(topNode.get()) - CONSTRUCTOR_DROP;</span>
		}
	}
	
	/*
	 * The root of the call sequence is the call node without a callee
	 */
	private Optional&lt;Node&gt; findRoot()
	{
<span class="fc" id="L313">		Set&lt;Node&gt; calledNodes = diagram().edges().stream()</span>
<span class="fc" id="L314">				.filter(edge -&gt; CallEdge.class.isAssignableFrom(edge.getClass())) // Includes subclasses, such as constructor edges</span>
<span class="fc" id="L315">				.map(Edge::end)</span>
<span class="fc" id="L316">				.collect(Collectors.toSet());</span>
<span class="fc" id="L317">		List&lt;Node&gt; rootNode = diagram().allNodes().stream()</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">				.filter(node -&gt; node.getClass() == CallNode.class)</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">				.filter(node -&gt; !calledNodes.contains(node))</span>
<span class="fc" id="L320">				.collect(Collectors.toList());</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">		assert rootNode.size() &lt;= 1; </span>
<span class="fc" id="L322">		Optional&lt;Node&gt; result = Optional.empty();</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">		if( !rootNode.isEmpty() )</span>
		{
<span class="fc" id="L325">			result = Optional.of(rootNode.get(0));</span>
		}
<span class="fc" id="L327">		return result;</span>
	}
	
	/**
	 * @param pNode An implicit parameter node.
	 * @return The x coordinate of the center of the node.
	 */
	public static int getCenterXCoordinate(ImplicitParameterNode pNode)
	{
<span class="fc" id="L336">		return ImplicitParameterNodeRenderer.getCenterXCoordinate(pNode);</span>
	}
	
	@Override
	protected Optional&lt;Node&gt; deepFindNode(Node pNode, Point pPoint)
	{
<span class="fc" id="L342">		Optional&lt;Node&gt; result = Optional.empty();</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">		if( pNode.getClass() == CallNode.class )</span>
		{
<span class="fc" id="L345">			result = getCallees(pNode).stream()</span>
<span class="fc" id="L346">				.map(node -&gt; deepFindNode(node, pPoint))</span>
<span class="fc" id="L347">				.filter(Optional::isPresent)</span>
<span class="fc" id="L348">				.map(Optional::get)</span>
<span class="fc" id="L349">				.findFirst();</span>
		}
<span class="fc" id="L351">		return result.or(() -&gt; super.deepFindNode(pNode, pPoint));</span>
	}
	
	/**
	 * Returns the list of nodes directly called by pNode,
	 * in the order of the call sequence.
	 * 
	 * @param pNode The node to obtain the callees for.
	 * @return All Nodes pointed to by an outgoing edge starting
	 *     at pNode, or the empty list if there are none.
	 * @pre pNode != null &amp;&amp; contains(pNode)
	 */
	private List&lt;Node&gt; getCallees(Node pNode)
	{
<span class="pc bpc" id="L365" title="2 of 4 branches missed.">		assert pNode != null &amp;&amp; diagram().contains(pNode);</span>
<span class="fc" id="L366">		return diagram().edges().stream()</span>
<span class="fc" id="L367">				.filter(CallEdge.class::isInstance)</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">				.filter(edge -&gt; edge.start() == pNode)</span>
<span class="fc" id="L369">				.map(Edge::end)</span>
<span class="fc" id="L370">				.collect(toList());</span>
	}
	
	/*
	 * This specialized version supports selecting implicit parameter nodes only by 
	 * selecting their top rectangle.
	 */
	@Override
	public Optional&lt;Node&gt; selectableNodeAt(Point pPoint)
	{
<span class="nc" id="L380">		Optional&lt;Node&gt; topRectangleSelected = diagram().rootNodes().stream()</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">			.filter(node -&gt; node.getClass() == ImplicitParameterNode.class)</span>
<span class="nc" id="L382">			.filter(node -&gt; ((ImplicitParameterNodeRenderer)rendererFor(ImplicitParameterNode.class))</span>
<span class="nc" id="L383">					.getTopRectangle(node).contains(pPoint))</span>
<span class="nc" id="L384">			.findFirst();</span>
<span class="nc" id="L385">		return topRectangleSelected.or(() -&gt; super.selectableNodeAt(pPoint));				</span>
	}
	
	/*
	 * @return The number of pixels to drop the call edges from the current position in the call sequence.
	 * Takes into account the size of the font to ensure labels on call edges do not overlap.
	 */
	private static int getDropDistance()
	{
<span class="fc" id="L394">		return Math.max(DROP_MIN, STRING_METRIC.getDimension(TEST_STRING).height());</span>
	}
	
	/**
	 * @return True if there is at least one call node in the diagram.
	 */
	public boolean hasEntryPoint()
	{
<span class="fc" id="L402">		return diagram().rootNodes().stream().anyMatch(SequenceDiagramRenderer::hasCallNode);</span>
	}
	
	private static boolean hasCallNode(Node pNode)
	{
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">		return pNode.getClass() == ImplicitParameterNode.class &amp;&amp;</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">				!pNode.getChildren().isEmpty();</span>
	}
	
	/**
	 * Returns the start node for pEdge if it is exclusive
	 * to pEdge, namely if it only has pEdge as an outgoing 
	 * call edge.
	 * 
	 * @param pEdge The Edge to obtain the edge start for.
	 * @return The Optional value of the start Node for pEdge.
	 * @pre pEdge != null
	 */
	public Optional&lt;DiagramElement&gt; getStartNodeIfExclusive(Edge pEdge)
	{
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">		assert pEdge != null;</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">		if( startNodeOnlyCalls(pEdge) )</span>
		{
<span class="fc" id="L425">			return Optional.of(pEdge.start());</span>
		}
<span class="fc bfc" id="L427" title="All 2 branches covered.">		else if( pEdge.getClass() == ConstructorEdge.class )</span>
		{
			// We delete the start node of pEdge if it does not have any caller and only makes calls to the 
			// object being constructed.
<span class="fc bfc" id="L431" title="All 2 branches covered.">			if( getCaller(pEdge.start()).isEmpty() &amp;&amp; </span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">					onlyCallsToASingleImplicitParameterNode(pEdge.start(), pEdge.end().getParent()) )</span>
			{
<span class="fc" id="L434">				return Optional.of(pEdge.start());</span>
			}
		}
<span class="fc" id="L437">		return Optional.empty();</span>
	}
	
	/* 
	 * returns true iif pEdge's start node only calls pEdge.
	 */
	private boolean startNodeOnlyCalls(Edge pEdge)
	{
<span class="pc bpc" id="L445" title="2 of 4 branches missed.">		assert pEdge != null &amp;&amp; pEdge.start() != null;</span>
<span class="fc" id="L446">		List&lt;CallEdge&gt; calls = getCalls(pEdge.start());</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">		return  getCaller(pEdge.start()).isEmpty() &amp;&amp;</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">				calls.size() == 1 &amp;&amp;</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">				calls.contains(pEdge);</span>
	}
	
	private boolean onlyCallsToASingleImplicitParameterNode(Node pCaller, Node pParentNode)
	{
<span class="pc bpc" id="L454" title="2 of 4 branches missed.">		assert pCaller!= null &amp;&amp; pParentNode != null;</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">		return getCalls(pCaller).stream().allMatch(edge -&gt; edge.end().getParent() == pParentNode);</span>
	}
	
	/**
	 * @param pCaller The caller node.
	 * @return The list of call edges starting at pCaller
	 * @pre pCaller != null
	 */
	private List&lt;CallEdge&gt; getCalls(Node pCaller)
	{
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">		assert pCaller != null;</span>
<span class="fc" id="L466">		return diagram().edges().stream()</span>
<span class="fc" id="L467">				.filter(CallEdge.class::isInstance)</span>
<span class="fc" id="L468">				.map(CallEdge.class::cast)</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">				.filter(edge -&gt; edge.start() == pCaller)</span>
<span class="fc" id="L470">				.collect(toList());</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>